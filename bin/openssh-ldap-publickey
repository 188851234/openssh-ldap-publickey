#!/usr/bin/perl

use Net::LDAP;
use POSIX qw(strftime);
use File::Basename;
use strict;
use warnings;

my $configuration_file = '/etc/ldap.conf';
my $secret_file = '/etc/ldap.secret';
my $version = '0.4.4';
my $prog_name = basename($0);

sub help {
    print "Usage: $prog_name <username>\n";
    print "Version: $version\n";
    print "\n";
    print "\t-h --help\tPrint this help message and exit\n";
    print "\t-v --version\tPrint the version number and exit\n";
    print "\n";
    print "Example:\n";
    print "\t". basename($0) ." username\n";
    print "If successful, it will write something like this to stdout:\n";
    print "\t".'ssh-rsa some_long_long_key user@hostname'."\n";
    exit;
}

sub version {
    my $version = shift;

    print "$version\n";
    exit;
}

sub parse_config {
    my ($config_file) = @_;

    my $conf;
    open(CONF, "<$config_file") or die("Configuration file $config_file does not exist");

    while(<CONF>) {
        next if ( $_ =~ /^#/ or $_ =~ /^\s+$/ );

        # convert to lower case
        my $line = lc($_);

        # remove leading whitespace
        $line =~ s/^\s+//;

        # remove trailing whitespace
        $line =~ s/\s+$//;

        my ($key,$val) = split(/\s+/, $line);
        $conf->{$key}=$val;
    }

    close(CONF);

    # Support nss_base_passwd with scope notation
    # example:
    # nss_base_passwd ou=People?one
    if (exists($conf->{'nss_base_passwd'}) && $conf->{'nss_base_passwd'} =~ /(.*)\?(.*)/) {
        if (defined($1) && length($1)) {
            $conf->{'nss_base_passwd'} = $1;
        }
        if (defined($2) && length($2)) {
            $conf->{'scope'} = $2;
        }
    }
    return($conf);
}

sub parse_secret_file {
    my $secret_file = shift;

    local(*INPUT, $/);
    open (INPUT, "<$secret_file");
    my $secret = <INPUT>;
    chomp($secret);
    close(INPUT);
    return($secret);
}

sub check_credentials {
    my $conf = shift;
    my $secret_file = shift;

    my $secret = undef;
    if ( -e $secret_file) {
        $secret = parse_secret_file($secret_file);
    }

    # When no binddn is found find out if we can find an alternative binddn.
    unless ( exists($conf->{'binddn'}) && length($conf->{'binddn'}) ) {
        if ( exists($conf->{'rootbinddn'}) && length($conf->{'rootbinddn'}) ) {
            $conf->{'binddn'} = $conf->{'rootbinddn'};
        }
    }

    # When no bindpw is found find out if we can find an alternative bindpw.
    unless ( exists($conf->{'bindpw'}) && length($conf->{'bindpw'})) {
        if (defined($secret) && length($secret)) {
            $conf->{'bindpw'} = $secret;
        }
    }
    return($conf);
}

sub writeToLog {
    my ($logfile, $log_level, $message) = @_;

    return 1 unless ($log_level);
    my $timestamp = strftime "%m/%d/%Y %H/%M/%S", localtime;
    open(LD, ">>$logfile");

    print LD "$timestamp: $message\n";

    close(LD);
}

help() if ( !defined($ARGV[0]) or $ARGV[0] eq '-h' or $ARGV[0] eq '--help' );
version($version) if ( $ARGV[0] eq '-v' or $ARGV[0] eq '--version' );

my $fallback_logfile = '/tmp/openssh-ldap-publickey.log';

if ( ! -e $configuration_file ) {
	my $error = "Configuration file $configuration_file does not exist";
	writeToLog($fallback_logfile, 1, "Configuration file $configuration_file does not exist");
	die($error."!\n");
}

my $conf = parse_config($configuration_file);

# Validate mandatory config settings
unless (
	exists($conf->{'base'}) && length($conf->{'base'}) &&
	exists($conf->{'uri'}) && length($conf->{'uri'})
) {
	my $error = "Missing one or more mandatory config settings: base and/or uri";
	writeToLog($fallback_logfile, 1, $error);
	die("$error".!"\n");
}


my $log_level = $conf->{'openssh_ldap_loglevel'};
my $logfile = $conf->{'openssh_ldap_logfile'} || $fallback_logfile;
my $timeout = $conf->{'timeout'} || 10;
my $nss_base_passwd = $conf->{'nss_base_passwd'} || "ou=People," .$conf->{'base'};
my $scope = $conf->{'scope'} || undef;
my ($mesg, $final_filter);
$conf = check_credentials($conf, $secret_file);

writeToLog($logfile, $log_level, "Connecting to ldap server $conf->{'uri'} with timeout $timeout");

my $ldap = Net::LDAP->new(
    $conf->{'uri'},
    timeout => $timeout
) or die "$@";

if (
	exists($conf->{'binddn'}) && length($conf->{'binddn'}) &&
	exists($conf->{'bindpw'})
) {
    writeToLog($logfile, $log_level, "Try to bind with user $conf->{'binddn'}");
    $ldap->bind(
        $conf->{'binddn'},
        password => $conf->{'bindpw'}
    );
} else {
    writeToLog($logfile, $log_level, "Try an anonymous bind");
    $ldap->bind or die("$@");
}

my $user = $ARGV[0];

if ( $conf->{'pam_filter'} ){
    $final_filter = "&(".$conf->{'pam_filter'}.")(uid=".$user.")";
} else {
    $final_filter = 'cn=*';
}

writeToLog($logfile, $log_level, "Searching key for user $user by filter $final_filter in base $nss_base_passwd");

my %search_params = (
    base => "$nss_base_passwd",
    filter => "$final_filter",
    defined($scope) ? (scope => 'one') : (),
    attrs => ['sshPublicKey', 'sshPublickey']
);
$mesg = $ldap->search(%search_params);

foreach my $entry ($mesg->entries) {
    my $keys = $entry->{asn}->{attributes}->[0]->{vals};
    foreach my $key (@$keys){
        writeToLog($logfile, $log_level, "Key found: $key");
        print "$key\n";
    }
}

writeToLog($logfile, $log_level, "Disconnecting");
$mesg = $ldap->unbind;
